<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>AESECB.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_2298ed0e5bfee6f293aea6c715ac7f7c.html">exports</a></li><li class="navelem"><a class="el" href="dir_909bee6dba95683a10cf8e43b6520a31.html">tidrivers_cc13xx_cc26xx_3_60_01_00</a></li><li class="navelem"><a class="el" href="dir_c5f8bfd2b00c3d9482b35ab5c4e473f6.html">source</a></li><li class="navelem"><a class="el" href="dir_06d62f3489950a654127c0b824c52048.html">ti</a></li><li class="navelem"><a class="el" href="dir_f72c65173629b6c97d424cefc852539a.html">drivers</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">AESECB.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>AESECB driver header. </p>
<p>============================================================================</p>
<dl class="section warning"><dt>Warning</dt><dd>This is a beta API. It may change in future releases.</dd></dl>
<h1>Overview</h1>
<p>The Electronic Code Book (ECB) mode of operation is a generic encryption block cipher mode. It can be used with any block cipher. AESECB encrypts or decrypts one or multiple blocks of plaintext or ciphertext using the Advanced Encryption Standard (AES) block cipher. Each input block is individually encrypted or decrypted. This means that blocks of ciphertext can be decrypted individually and out of order. Encrypting the same plaintext using the same key yields identical ciphertext. This raises several security issues. For this reason, it is not recommended that ECB be used unless interfacing with unupdatable legacy systems or where a standard specifies its use. Better alternatives would be an authenticated encryption with associated data (AEAD) mode such as CCM or GCM.</p>
<p>The AES key is a shared secret between the two parties and has a length of 128, 192, or 256 bits.</p>
<h1>Usage</h1>
<h2>Before starting an ECB operation</h2>
<p>Before starting an ECB operation, the application must do the following:</p><ul>
<li>Call <a class="el" href="_a_e_s_e_c_b_8h.html#a4f4274c6aa928e8e10d3e516e73f77ea" title="This function initializes the ECB module. ">AESECB_init()</a> to initialize the driver</li>
<li>Call <a class="el" href="_a_e_s_e_c_b_8h.html#ab200c39cb5a9cc537a9a6047c89d5651" title="Function to initialize the AESECB_Params struct to its defaults. ">AESECB_Params_init()</a> to initialize the AESECB_Params to default values.</li>
<li>Modify the AESECB_Params as desired</li>
<li>Call <a class="el" href="_a_e_s_e_c_b_8h.html#aa09623a2b4bc9cfa608865bc502ca10e" title="This function opens a given ECB peripheral. ">AESECB_open()</a> to open an instance of the driver</li>
<li>Initialize a CryptoKey. These opaque datastructures are representations of keying material and its storage. Depending on how the keying material is stored (RAM or flash, key store, key blob), the CryptoKey must be initialized differently. The AESECB API can handle all types of CryptoKey. However, not all device-specific implementions support all types of CryptoKey. Devices without a key store will not support CryptoKeys with keying material stored in a key store for example. All devices support plaintext CryptoKeys.</li>
<li>Initialize the AESECB_Operation using <a class="el" href="_a_e_s_e_c_b_8h.html#a44a248dfcc9794b28a2eb8eb5570af2d" title="Function to initialize an AESECB_Operation struct to its defaults. ">AESECB_Operation_init()</a> and set all length, key, and buffer fields.</li>
</ul>
<h2>Starting an ECB operation</h2>
<p>The AESECB_oneStepEncrypt and AESECB_oneStepDecrypt functions do an ECB operation in a single call. They will always be the most highly optimized routines with the least overhead and the fastest runtime. Since ECB plaintext blocks are simply encrypted with the block cipher block by block, there is no difference in the ciphertext between encrypting two blocks in one go or encypting each block individually.</p>
<h2>After the ECB operation completes</h2>
<p>After the ECB operation completes, the application should either start another operation or close the driver by calling <a class="el" href="_a_e_s_e_c_b_8h.html#a55c096b42583d88be9f044dcffad64a8" title="Function to close an ECB peripheral specified by the ECB handle. ">AESECB_close()</a></p>
<h2>AESECB Driver Configuration</h2>
<p>In order to use the AESECB APIs, the application is required to provide device-specific AESECB configuration in the Board.c file. The AESECB driver interface defines a configuration data structure:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct_a_e_s_e_c_b___config__.html">AESECB_Config_</a> {</div><div class="line">    <span class="keywordtype">void</span>                   *<a class="code" href="struct_a_e_s_e_c_b___config__.html#a560351ad7ffe300a7e993f194366e6f5">object</a>;</div><div class="line">    <span class="keywordtype">void</span>          <span class="keyword">const</span>    *<a class="code" href="struct_a_e_s_e_c_b___config__.html#aa17a92ee782df93ff276eadf1a0daeb1">hwAttrs</a>;</div><div class="line">} <a class="code" href="_a_e_s_e_c_b_8h.html#a5b0240a11da9753290532045e222618a">AESECB_Config</a>;</div></div><!-- fragment --><p>The application must declare an array of AESECB_Config elements, named AESECB_config[]. Each element of AESECB_config[] must be populated with pointers to a device specific AESECB driver implementation's driver object and hardware attributes. The hardware attributes define properties such as the AESECB peripheral's base address. Each element in AESECB_config[] corresponds to an AESECB instance and none of the elements should have NULL pointers. There is no correlation between the index and the peripheral designation (such as AESECB0 or AESECB1). For example, it is possible to use AESECB_config[0] for AESECB1. Multiple drivers and driver instances may all access the same underlying hardware. This is transparent to the application. Mutual exclusion is performed automatically by the drivers as necessary.</p>
<p>Because the AESECB configuration is very device dependent, you will need to check the doxygen for the device specific AESECB implementation. There you will find a description of the AESECB hardware attributes. Please also refer to the Board.c file of any of your examples to see the AESECB configuration.</p>
<h2>AESECB Parameters</h2>
<p>The <a class="el" href="_a_e_s_e_c_b_8h.html#a257708194f9c44237ba4195fe5153ac1" title="ECB Parameters. ">AESECB_Params</a> structure is passed to the <a class="el" href="_a_e_s_e_c_b_8h.html#aa09623a2b4bc9cfa608865bc502ca10e" title="This function opens a given ECB peripheral. ">AESECB_open()</a> call. If NULL is passed for the parameters, <a class="el" href="_a_e_s_e_c_b_8h.html#aa09623a2b4bc9cfa608865bc502ca10e" title="This function opens a given ECB peripheral. ">AESECB_open()</a> uses default parameters. An <a class="el" href="_a_e_s_e_c_b_8h.html#a257708194f9c44237ba4195fe5153ac1" title="ECB Parameters. ">AESECB_Params</a> structure is initialized with default values by passing it to <a class="el" href="_a_e_s_e_c_b_8h.html#ab200c39cb5a9cc537a9a6047c89d5651" title="Function to initialize the AESECB_Params struct to its defaults. ">AESECB_Params_init()</a>.</p>
<h2>Examples</h2>
<p>### Encyption of multiple plaintext blocks in blocking mode # </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_a_e_s_e_c_b_8h.html">ti/drivers/AESECB.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;ti/drivers/types/cryptoKey/CryptoKey_Plaintext.h&gt;</span></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">AESECB_Handle handle;</div><div class="line"><a class="code" href="struct_crypto_key__.html">CryptoKey</a> cryptoKey;</div><div class="line">int_fast16_t encryptionResult;</div><div class="line">uint8_t plaintext[] = {0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,</div><div class="line">                       0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,</div><div class="line">                       0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,</div><div class="line">                       0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51};</div><div class="line">uint8_t ciphertext[sizof(plaintext)];</div><div class="line">uint8_t keyingMaterial[16] = {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,</div><div class="line">                              0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c}</div><div class="line"></div><div class="line">handle = <a class="code" href="_a_e_s_e_c_b_8h.html#aa09623a2b4bc9cfa608865bc502ca10e">AESECB_open</a>(0, NULL);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (handle == NULL) {</div><div class="line">    <span class="comment">// handle error</span></div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="_crypto_key_plaintext_8h.html#ace81a1078fd0befbde3f44a9d9d58cc4">CryptoKeyPlaintext_initKey</a>(&amp;cryptoKey, keyingMaterial, <span class="keyword">sizeof</span>(keyingMaterial));</div><div class="line"></div><div class="line">    <a class="code" href="struct_a_e_s_e_c_b___operation__.html">AESECB_Operation</a> operation;</div><div class="line">    <a class="code" href="_a_e_s_e_c_b_8h.html#a44a248dfcc9794b28a2eb8eb5570af2d">AESECB_Operation_init</a>(&amp;operation);</div><div class="line"></div><div class="line">    operation.<a class="code" href="struct_a_e_s_e_c_b___operation__.html#af4c69e3e63f9b1a58ea0e5023e169456">key</a>               = &amp;cryptoKey;</div><div class="line">    operation.<a class="code" href="struct_a_e_s_e_c_b___operation__.html#aa0e01886152511f41da7ae4d750ade7e">input</a>             = plaintext;</div><div class="line">    operation.<a class="code" href="struct_a_e_s_e_c_b___operation__.html#a66e39e70d1fe17ebea21b91fcd87cc5b">output</a>            = ciphertext;</div><div class="line">    operation.<a class="code" href="struct_a_e_s_e_c_b___operation__.html#af3b53823e40fd824e2b693202b24a9d0">inputLength</a>       = <span class="keyword">sizeof</span>(plaintext);</div><div class="line"></div><div class="line">encryptionResult = <a class="code" href="_a_e_s_e_c_b_8h.html#a8b760e2e52d714c3fb8faf74feb38b3a">AESECB_oneStepEncrypt</a>(handle, &amp;operation);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (encryptionResult != <a class="code" href="group___a_e_s_e_c_b___s_t_a_t_u_s.html#ga6dfa9afab09668259531f58273fa4e36">AESECB_STATUS_SUCCESS</a>) {</div><div class="line">    <span class="comment">// handle error</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// The resultant ciphertext should be:</span></div><div class="line"><span class="comment">// 0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60,</span></div><div class="line"><span class="comment">// 0xa8, 0x9e, 0xca, 0xf3, 0x24, 0x66, 0xef, 0x97,</span></div><div class="line"><span class="comment">// 0xf5, 0xd3, 0xd5, 0x85, 0x03, 0xb9, 0x69, 0x9d,</span></div><div class="line"><span class="comment">// 0xe7, 0x85, 0x89, 0x5a, 0x96, 0xfd, 0xba, 0xaf</span></div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="_a_e_s_e_c_b_8h.html#a55c096b42583d88be9f044dcffad64a8">AESECB_close</a>(handle);</div></div><!-- fragment --><h3>Single call ECB decryption in callback mode</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_a_e_s_e_c_b_8h.html">ti/drivers/AESECB.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_crypto_key_plaintext_8h.html">ti/drivers/cryptoutils/cryptokey/CryptoKeyPlaintext.h</a>&gt;</span></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">uint8_t ciphertext[]                    = {0xf3, 0xee, 0xd1, 0xbd, 0xb5, 0xd2, 0xa0, 0x3c,</div><div class="line">                                           0x06, 0x4b, 0x5a, 0x7e, 0x3d, 0xb1, 0x81, 0xf8};</div><div class="line">uint8_t keyingMaterial[32]              = {0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe,</div><div class="line">                                           0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,</div><div class="line">                                           0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7,</div><div class="line">                                           0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4};</div><div class="line">uint8_t plaintext[<span class="keyword">sizeof</span>(ciphertext)];</div><div class="line"></div><div class="line"><span class="comment">// The plaintext should be the following after the decryption operation:</span></div><div class="line"><span class="comment">// 0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,</span></div><div class="line"><span class="comment">// 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> ecbCallback(<a class="code" href="struct_a_e_s_e_c_b___config__.html">AESECB_Handle</a> handle,</div><div class="line">                 int_fast16_t returnValue,</div><div class="line">                 <a class="code" href="struct_a_e_s_e_c_b___operation__.html">AESECB_Operation</a> *operation,</div><div class="line">                 <a class="code" href="_a_e_s_e_c_b_8h.html#a6b3d4d7c2079015bd053e3a977e743d6">AESECB_OperationType</a> operationType) {</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (returnValue != <a class="code" href="group___a_e_s_e_c_b___s_t_a_t_u_s.html#ga6dfa9afab09668259531f58273fa4e36">AESECB_STATUS_SUCCESS</a>) {</div><div class="line">        <span class="comment">// handle error</span></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="struct_a_e_s_e_c_b___operation__.html">AESECB_Operation</a> operation;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> ecbStartFunction(<span class="keywordtype">void</span>) {</div><div class="line">    <a class="code" href="struct_a_e_s_e_c_b___config__.html">AESECB_Handle</a> handle;</div><div class="line">    <a class="code" href="struct_a_e_s_e_c_b___params__.html">AESECB_Params</a> params;</div><div class="line">    <a class="code" href="struct_crypto_key__.html">CryptoKey</a> cryptoKey;</div><div class="line">    int_fast16_t decryptionResult;</div><div class="line"></div><div class="line">    <a class="code" href="_a_e_s_e_c_b_8h.html#ab200c39cb5a9cc537a9a6047c89d5651">AESECB_Params_init</a>(&amp;params);</div><div class="line">    params.<a class="code" href="struct_a_e_s_e_c_b___params__.html#a9cbbd764090d5fb6f0bcaa2e4ada976a">returnBehavior</a> = <a class="code" href="_a_e_s_e_c_b_8h.html#a4f72d10dea0dcaa6d8cee8de8eb0981aa945f7703e248cd2d0fc2a08077030e62">AESECB_RETURN_BEHAVIOR_CALLBACK</a>;</div><div class="line">    params.<a class="code" href="struct_a_e_s_e_c_b___params__.html#a5767eed05a8d8c5a8830446f524748cf">callbackFxn</a> = ecbCallback;</div><div class="line"></div><div class="line">    handle = <a class="code" href="_a_e_s_e_c_b_8h.html#aa09623a2b4bc9cfa608865bc502ca10e">AESECB_open</a>(0, &amp;params);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (handle == NULL) {</div><div class="line">        <span class="comment">// handle error</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="_crypto_key_plaintext_8h.html#ace81a1078fd0befbde3f44a9d9d58cc4">CryptoKeyPlaintext_initKey</a>(&amp;cryptoKey, keyingMaterial, <span class="keyword">sizeof</span>(keyingMaterial));</div><div class="line"></div><div class="line">    <a class="code" href="_a_e_s_e_c_b_8h.html#a44a248dfcc9794b28a2eb8eb5570af2d">AESECB_Operation_init</a>(&amp;operation);</div><div class="line"></div><div class="line">    operation.<a class="code" href="struct_a_e_s_e_c_b___operation__.html#af4c69e3e63f9b1a58ea0e5023e169456">key</a>               = &amp;cryptoKey;</div><div class="line">    operation.<a class="code" href="struct_a_e_s_e_c_b___operation__.html#aa0e01886152511f41da7ae4d750ade7e">input</a>             = plaintext;</div><div class="line">    operation.<a class="code" href="struct_a_e_s_e_c_b___operation__.html#a66e39e70d1fe17ebea21b91fcd87cc5b">output</a>            = ciphertext;</div><div class="line">    operation.<a class="code" href="struct_a_e_s_e_c_b___operation__.html#af3b53823e40fd824e2b693202b24a9d0">inputLength</a>       = <span class="keyword">sizeof</span>(plaintext);</div><div class="line"></div><div class="line">    decryptionResult = <a class="code" href="_a_e_s_e_c_b_8h.html#abdd64e5e2b446ef0b884f9d3862d0463">AESECB_oneStepDecrypt</a>(handle, &amp;operation);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (decryptionResult != <a class="code" href="group___a_e_s_e_c_b___s_t_a_t_u_s.html#ga6dfa9afab09668259531f58273fa4e36">AESECB_STATUS_SUCCESS</a>) {</div><div class="line">        <span class="comment">// handle error</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// do other things while ECB operation completes in the background</span></div><div class="line"></div><div class="line">}</div></div><!-- fragment --> </div><div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;<a class="el" href="_crypto_key_8h_source.html">ti/drivers/cryptoutils/cryptokey/CryptoKey.h</a>&gt;</code><br />
</div>
<p><a href="_a_e_s_e_c_b_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_e_s_e_c_b___operation__.html">AESECB_Operation_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing the parameters required for encrypting/decrypting and a message.  <a href="struct_a_e_s_e_c_b___operation__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_e_s_e_c_b___config__.html">AESECB_Config_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AESECB Global configuration.  <a href="struct_a_e_s_e_c_b___config__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_e_s_e_c_b___params__.html">AESECB_Params_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECB Parameters.  <a href="struct_a_e_s_e_c_b___params__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga2b81e4bb70e7d17adbe05ac783bdbf04"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_e_c_b___c_o_n_t_r_o_l.html#ga2b81e4bb70e7d17adbe05ac783bdbf04">AESECB_CMD_RESERVED</a>&#160;&#160;&#160;(32)</td></tr>
<tr class="separator:ga2b81e4bb70e7d17adbe05ac783bdbf04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d1005b6b5eed999a82f89f282bf384f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_e_c_b___c_o_n_t_r_o_l.html#ga5d1005b6b5eed999a82f89f282bf384f">AESECB_STATUS_RESERVED</a>&#160;&#160;&#160;(-32)</td></tr>
<tr class="separator:ga5d1005b6b5eed999a82f89f282bf384f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dfa9afab09668259531f58273fa4e36"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_e_c_b___s_t_a_t_u_s.html#ga6dfa9afab09668259531f58273fa4e36">AESECB_STATUS_SUCCESS</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:ga6dfa9afab09668259531f58273fa4e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Successful status code.  <a href="group___a_e_s_e_c_b___s_t_a_t_u_s.html#ga6dfa9afab09668259531f58273fa4e36">More...</a><br /></td></tr>
<tr class="separator:ga6dfa9afab09668259531f58273fa4e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8792e83e4a2350e94b1f2a32d4886a2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_e_c_b___s_t_a_t_u_s.html#gab8792e83e4a2350e94b1f2a32d4886a2">AESECB_STATUS_ERROR</a>&#160;&#160;&#160;(-1)</td></tr>
<tr class="memdesc:gab8792e83e4a2350e94b1f2a32d4886a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic error status code.  <a href="group___a_e_s_e_c_b___s_t_a_t_u_s.html#gab8792e83e4a2350e94b1f2a32d4886a2">More...</a><br /></td></tr>
<tr class="separator:gab8792e83e4a2350e94b1f2a32d4886a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47b06b0e611caf88cae681be4c56e105"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_e_c_b___s_t_a_t_u_s.html#ga47b06b0e611caf88cae681be4c56e105">AESECB_STATUS_UNDEFINEDCMD</a>&#160;&#160;&#160;(-2)</td></tr>
<tr class="memdesc:ga47b06b0e611caf88cae681be4c56e105"><td class="mdescLeft">&#160;</td><td class="mdescRight">An error status code returned by <a class="el" href="_a_e_s_e_c_b_8h.html#ac59e0fb45736632843a8e43cd2e79575" title="Function performs implementation specific features on a given AESECB_Handle. ">AESECB_control()</a> for undefined command codes.  <a href="group___a_e_s_e_c_b___s_t_a_t_u_s.html#ga47b06b0e611caf88cae681be4c56e105">More...</a><br /></td></tr>
<tr class="separator:ga47b06b0e611caf88cae681be4c56e105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d09cd5661ac53f7ba3141e23fde65a6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_e_s_e_c_b___s_t_a_t_u_s.html#ga5d09cd5661ac53f7ba3141e23fde65a6">AESECB_STATUS_RESOURCE_UNAVAILABLE</a>&#160;&#160;&#160;(-3)</td></tr>
<tr class="memdesc:ga5d09cd5661ac53f7ba3141e23fde65a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">An error status code returned if the hardware or software resource is currently unavailable.  <a href="group___a_e_s_e_c_b___s_t_a_t_u_s.html#ga5d09cd5661ac53f7ba3141e23fde65a6">More...</a><br /></td></tr>
<tr class="separator:ga5d09cd5661ac53f7ba3141e23fde65a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aca185011358823a4bbcd0c8f950bc960"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_a_e_s_e_c_b___config__.html">AESECB_Config_</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_e_c_b_8h.html#aca185011358823a4bbcd0c8f950bc960">AESECB_Handle</a></td></tr>
<tr class="memdesc:aca185011358823a4bbcd0c8f950bc960"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle that is returned from an <a class="el" href="_a_e_s_e_c_b_8h.html#aa09623a2b4bc9cfa608865bc502ca10e" title="This function opens a given ECB peripheral. ">AESECB_open()</a> call.  <a href="#aca185011358823a4bbcd0c8f950bc960">More...</a><br /></td></tr>
<tr class="separator:aca185011358823a4bbcd0c8f950bc960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43cf8816fe28d9a4aadeb19ad716be65"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_a_e_s_e_c_b_8h.html#a4f72d10dea0dcaa6d8cee8de8eb0981a">AESECB_ReturnBehavior_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_e_c_b_8h.html#a43cf8816fe28d9a4aadeb19ad716be65">AESECB_ReturnBehavior</a></td></tr>
<tr class="memdesc:a43cf8816fe28d9a4aadeb19ad716be65"><td class="mdescLeft">&#160;</td><td class="mdescRight">The way in which ECB function calls return after performing an encryption + authentication or decryption + verification operation.  <a href="#a43cf8816fe28d9a4aadeb19ad716be65">More...</a><br /></td></tr>
<tr class="separator:a43cf8816fe28d9a4aadeb19ad716be65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ffb2f4ad66f7981ed41de08d444a29"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_a_e_s_e_c_b_8h.html#aa3b7be874253e102ae98dd23c9319e9f">AESECB_Mode_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_e_c_b_8h.html#a63ffb2f4ad66f7981ed41de08d444a29">AESECB_Mode</a></td></tr>
<tr class="memdesc:a63ffb2f4ad66f7981ed41de08d444a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for the direction of the ECB operation.  <a href="#a63ffb2f4ad66f7981ed41de08d444a29">More...</a><br /></td></tr>
<tr class="separator:a63ffb2f4ad66f7981ed41de08d444a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa5948ef2d83d659861aff16ddf95cb"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_a_e_s_e_c_b___operation__.html">AESECB_Operation_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_e_c_b_8h.html#a0aa5948ef2d83d659861aff16ddf95cb">AESECB_Operation</a></td></tr>
<tr class="memdesc:a0aa5948ef2d83d659861aff16ddf95cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing the parameters required for encrypting/decrypting and a message.  <a href="#a0aa5948ef2d83d659861aff16ddf95cb">More...</a><br /></td></tr>
<tr class="separator:a0aa5948ef2d83d659861aff16ddf95cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3d4d7c2079015bd053e3a977e743d6"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_a_e_s_e_c_b_8h.html#a00e385048eba5991c317d9b771789be7">AESECB_OperationType_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_e_c_b_8h.html#a6b3d4d7c2079015bd053e3a977e743d6">AESECB_OperationType</a></td></tr>
<tr class="memdesc:a6b3d4d7c2079015bd053e3a977e743d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for the operation types supported by the driver.  <a href="#a6b3d4d7c2079015bd053e3a977e743d6">More...</a><br /></td></tr>
<tr class="separator:a6b3d4d7c2079015bd053e3a977e743d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0240a11da9753290532045e222618a"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_a_e_s_e_c_b___config__.html">AESECB_Config_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_e_c_b_8h.html#a5b0240a11da9753290532045e222618a">AESECB_Config</a></td></tr>
<tr class="memdesc:a5b0240a11da9753290532045e222618a"><td class="mdescLeft">&#160;</td><td class="mdescRight">AESECB Global configuration.  <a href="#a5b0240a11da9753290532045e222618a">More...</a><br /></td></tr>
<tr class="separator:a5b0240a11da9753290532045e222618a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2017e1521b3eeb49c8917dbe1dabf953"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_e_c_b_8h.html#a2017e1521b3eeb49c8917dbe1dabf953">AESECB_CallbackFxn</a>) (<a class="el" href="_a_e_s_e_c_b_8h.html#aca185011358823a4bbcd0c8f950bc960">AESECB_Handle</a> handle, int_fast16_t returnValue, <a class="el" href="_a_e_s_e_c_b_8h.html#a0aa5948ef2d83d659861aff16ddf95cb">AESECB_Operation</a> *operation, <a class="el" href="_a_e_s_e_c_b_8h.html#a6b3d4d7c2079015bd053e3a977e743d6">AESECB_OperationType</a> operationType)</td></tr>
<tr class="memdesc:a2017e1521b3eeb49c8917dbe1dabf953"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a callback function used by the AESECB driver when used in <a class="el" href="_a_e_s_e_c_b_8h.html#a4f72d10dea0dcaa6d8cee8de8eb0981aa945f7703e248cd2d0fc2a08077030e62">AESECB_RETURN_BEHAVIOR_CALLBACK</a>.  <a href="#a2017e1521b3eeb49c8917dbe1dabf953">More...</a><br /></td></tr>
<tr class="separator:a2017e1521b3eeb49c8917dbe1dabf953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257708194f9c44237ba4195fe5153ac1"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_a_e_s_e_c_b___params__.html">AESECB_Params_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_e_c_b_8h.html#a257708194f9c44237ba4195fe5153ac1">AESECB_Params</a></td></tr>
<tr class="memdesc:a257708194f9c44237ba4195fe5153ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">ECB Parameters.  <a href="#a257708194f9c44237ba4195fe5153ac1">More...</a><br /></td></tr>
<tr class="separator:a257708194f9c44237ba4195fe5153ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a4f72d10dea0dcaa6d8cee8de8eb0981a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_e_c_b_8h.html#a4f72d10dea0dcaa6d8cee8de8eb0981a">AESECB_ReturnBehavior_</a> { <a class="el" href="_a_e_s_e_c_b_8h.html#a4f72d10dea0dcaa6d8cee8de8eb0981aa945f7703e248cd2d0fc2a08077030e62">AESECB_RETURN_BEHAVIOR_CALLBACK</a> = 1, 
<a class="el" href="_a_e_s_e_c_b_8h.html#a4f72d10dea0dcaa6d8cee8de8eb0981aa09c85edf8278d95609ef9cda74e21640">AESECB_RETURN_BEHAVIOR_BLOCKING</a> = 2, 
<a class="el" href="_a_e_s_e_c_b_8h.html#a4f72d10dea0dcaa6d8cee8de8eb0981aa8fb6022bf8730ca0f113fe339b3cf0d3">AESECB_RETURN_BEHAVIOR_POLLING</a> = 4
 }<tr class="memdesc:a4f72d10dea0dcaa6d8cee8de8eb0981a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The way in which ECB function calls return after performing an encryption + authentication or decryption + verification operation.  <a href="_a_e_s_e_c_b_8h.html#a4f72d10dea0dcaa6d8cee8de8eb0981a">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a4f72d10dea0dcaa6d8cee8de8eb0981a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b7be874253e102ae98dd23c9319e9f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_e_c_b_8h.html#aa3b7be874253e102ae98dd23c9319e9f">AESECB_Mode_</a> { <a class="el" href="_a_e_s_e_c_b_8h.html#aa3b7be874253e102ae98dd23c9319e9fa444b0bc4a6fa39374155fc2f67fc6a94">AESECB_MODE_ENCRYPT</a> = 1, 
<a class="el" href="_a_e_s_e_c_b_8h.html#aa3b7be874253e102ae98dd23c9319e9fa2957e9be6c5c1ce87d927609ce47fb6d">AESECB_MODE_DECRYPT</a> = 2
 }<tr class="memdesc:aa3b7be874253e102ae98dd23c9319e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for the direction of the ECB operation.  <a href="_a_e_s_e_c_b_8h.html#aa3b7be874253e102ae98dd23c9319e9f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aa3b7be874253e102ae98dd23c9319e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e385048eba5991c317d9b771789be7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_e_c_b_8h.html#a00e385048eba5991c317d9b771789be7">AESECB_OperationType_</a> { <a class="el" href="_a_e_s_e_c_b_8h.html#a00e385048eba5991c317d9b771789be7af9c903637981109af6af15c94aaf36b5">AESECB_OPERATION_TYPE_ENCRYPT</a> = 1, 
<a class="el" href="_a_e_s_e_c_b_8h.html#a00e385048eba5991c317d9b771789be7af42ad89357fc2f25e83fb4d7033bc08a">AESECB_OPERATION_TYPE_DECRYPT</a> = 2
 }<tr class="memdesc:a00e385048eba5991c317d9b771789be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for the operation types supported by the driver.  <a href="_a_e_s_e_c_b_8h.html#a00e385048eba5991c317d9b771789be7">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a00e385048eba5991c317d9b771789be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4f4274c6aa928e8e10d3e516e73f77ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_e_c_b_8h.html#a4f4274c6aa928e8e10d3e516e73f77ea">AESECB_init</a> (void)</td></tr>
<tr class="memdesc:a4f4274c6aa928e8e10d3e516e73f77ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the ECB module.  <a href="#a4f4274c6aa928e8e10d3e516e73f77ea">More...</a><br /></td></tr>
<tr class="separator:a4f4274c6aa928e8e10d3e516e73f77ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab200c39cb5a9cc537a9a6047c89d5651"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_e_c_b_8h.html#ab200c39cb5a9cc537a9a6047c89d5651">AESECB_Params_init</a> (<a class="el" href="_a_e_s_e_c_b_8h.html#a257708194f9c44237ba4195fe5153ac1">AESECB_Params</a> *params)</td></tr>
<tr class="memdesc:ab200c39cb5a9cc537a9a6047c89d5651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize the AESECB_Params struct to its defaults.  <a href="#ab200c39cb5a9cc537a9a6047c89d5651">More...</a><br /></td></tr>
<tr class="separator:ab200c39cb5a9cc537a9a6047c89d5651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09623a2b4bc9cfa608865bc502ca10e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_a_e_s_e_c_b_8h.html#aca185011358823a4bbcd0c8f950bc960">AESECB_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_e_c_b_8h.html#aa09623a2b4bc9cfa608865bc502ca10e">AESECB_open</a> (uint_least8_t index, <a class="el" href="_a_e_s_e_c_b_8h.html#a257708194f9c44237ba4195fe5153ac1">AESECB_Params</a> *params)</td></tr>
<tr class="memdesc:aa09623a2b4bc9cfa608865bc502ca10e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function opens a given ECB peripheral.  <a href="#aa09623a2b4bc9cfa608865bc502ca10e">More...</a><br /></td></tr>
<tr class="separator:aa09623a2b4bc9cfa608865bc502ca10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c096b42583d88be9f044dcffad64a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_e_c_b_8h.html#a55c096b42583d88be9f044dcffad64a8">AESECB_close</a> (<a class="el" href="_a_e_s_e_c_b_8h.html#aca185011358823a4bbcd0c8f950bc960">AESECB_Handle</a> handle)</td></tr>
<tr class="memdesc:a55c096b42583d88be9f044dcffad64a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to close an ECB peripheral specified by the ECB handle.  <a href="#a55c096b42583d88be9f044dcffad64a8">More...</a><br /></td></tr>
<tr class="separator:a55c096b42583d88be9f044dcffad64a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59e0fb45736632843a8e43cd2e79575"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_e_c_b_8h.html#ac59e0fb45736632843a8e43cd2e79575">AESECB_control</a> (<a class="el" href="_a_e_s_e_c_b_8h.html#aca185011358823a4bbcd0c8f950bc960">AESECB_Handle</a> handle, uint32_t cmd, void *args)</td></tr>
<tr class="memdesc:ac59e0fb45736632843a8e43cd2e79575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function performs implementation specific features on a given AESECB_Handle.  <a href="#ac59e0fb45736632843a8e43cd2e79575">More...</a><br /></td></tr>
<tr class="separator:ac59e0fb45736632843a8e43cd2e79575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a248dfcc9794b28a2eb8eb5570af2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_e_c_b_8h.html#a44a248dfcc9794b28a2eb8eb5570af2d">AESECB_Operation_init</a> (<a class="el" href="_a_e_s_e_c_b_8h.html#a0aa5948ef2d83d659861aff16ddf95cb">AESECB_Operation</a> *operationStruct)</td></tr>
<tr class="memdesc:a44a248dfcc9794b28a2eb8eb5570af2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize an AESECB_Operation struct to its defaults.  <a href="#a44a248dfcc9794b28a2eb8eb5570af2d">More...</a><br /></td></tr>
<tr class="separator:a44a248dfcc9794b28a2eb8eb5570af2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b760e2e52d714c3fb8faf74feb38b3a"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_e_c_b_8h.html#a8b760e2e52d714c3fb8faf74feb38b3a">AESECB_oneStepEncrypt</a> (<a class="el" href="_a_e_s_e_c_b_8h.html#aca185011358823a4bbcd0c8f950bc960">AESECB_Handle</a> handle, <a class="el" href="_a_e_s_e_c_b_8h.html#a0aa5948ef2d83d659861aff16ddf95cb">AESECB_Operation</a> *operation)</td></tr>
<tr class="memdesc:a8b760e2e52d714c3fb8faf74feb38b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to perform an AESECB encryption operation in one call.  <a href="#a8b760e2e52d714c3fb8faf74feb38b3a">More...</a><br /></td></tr>
<tr class="separator:a8b760e2e52d714c3fb8faf74feb38b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd64e5e2b446ef0b884f9d3862d0463"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_e_c_b_8h.html#abdd64e5e2b446ef0b884f9d3862d0463">AESECB_oneStepDecrypt</a> (<a class="el" href="_a_e_s_e_c_b_8h.html#aca185011358823a4bbcd0c8f950bc960">AESECB_Handle</a> handle, <a class="el" href="_a_e_s_e_c_b_8h.html#a0aa5948ef2d83d659861aff16ddf95cb">AESECB_Operation</a> *operation)</td></tr>
<tr class="memdesc:abdd64e5e2b446ef0b884f9d3862d0463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to perform an AESECB decryption in one call.  <a href="#abdd64e5e2b446ef0b884f9d3862d0463">More...</a><br /></td></tr>
<tr class="separator:abdd64e5e2b446ef0b884f9d3862d0463"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7a7eab07a0ed40f1e9320f973a74fb8e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_a_e_s_e_c_b_8h.html#a257708194f9c44237ba4195fe5153ac1">AESECB_Params</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_a_e_s_e_c_b_8h.html#a7a7eab07a0ed40f1e9320f973a74fb8e">AESECB_defaultParams</a></td></tr>
<tr class="memdesc:a7a7eab07a0ed40f1e9320f973a74fb8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default AESECB_Params structure.  <a href="#a7a7eab07a0ed40f1e9320f973a74fb8e">More...</a><br /></td></tr>
<tr class="separator:a7a7eab07a0ed40f1e9320f973a74fb8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aca185011358823a4bbcd0c8f950bc960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca185011358823a4bbcd0c8f950bc960">&sect;&nbsp;</a></span>AESECB_Handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_a_e_s_e_c_b___config__.html">AESECB_Config_</a>* <a class="el" href="_a_e_s_e_c_b_8h.html#aca185011358823a4bbcd0c8f950bc960">AESECB_Handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A handle that is returned from an <a class="el" href="_a_e_s_e_c_b_8h.html#aa09623a2b4bc9cfa608865bc502ca10e" title="This function opens a given ECB peripheral. ">AESECB_open()</a> call. </p>

</div>
</div>
<a id="a43cf8816fe28d9a4aadeb19ad716be65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43cf8816fe28d9a4aadeb19ad716be65">&sect;&nbsp;</a></span>AESECB_ReturnBehavior</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_a_e_s_e_c_b_8h.html#a4f72d10dea0dcaa6d8cee8de8eb0981a">AESECB_ReturnBehavior_</a>  <a class="el" href="_a_e_s_e_c_b_8h.html#a43cf8816fe28d9a4aadeb19ad716be65">AESECB_ReturnBehavior</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The way in which ECB function calls return after performing an encryption + authentication or decryption + verification operation. </p>
<p>Not all ECB operations exhibit the specified return behavor. Functions that do not require significant computation and cannot offload that computation to a background thread behave like regular functions. Which functions exhibit the specfied return behavior is not implementation dependent. Specifically, a software-backed implementation run on the same CPU as the application will emulate the return behavior while not actually offloading the computation to the background thread.</p>
<p>AESECB functions exhibiting the specified return behavior have restrictions on the context from which they may be called.</p>
<table class="doxtable">
<tr>
<th></th><th>Task </th><th>Hwi </th><th>Swi  </th></tr>
<tr>
<td>AESECB_RETURN_BEHAVIOR_CALLBACK </td><td>X </td><td>X </td><td>X </td></tr>
<tr>
<td>AESECB_RETURN_BEHAVIOR_BLOCKING </td><td>X </td><td></td><td></td></tr>
<tr>
<td>AESECB_RETURN_BEHAVIOR_POLLING </td><td>X </td><td>X </td><td>X </td></tr>
</table>

</div>
</div>
<a id="a63ffb2f4ad66f7981ed41de08d444a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ffb2f4ad66f7981ed41de08d444a29">&sect;&nbsp;</a></span>AESECB_Mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_a_e_s_e_c_b_8h.html#aa3b7be874253e102ae98dd23c9319e9f">AESECB_Mode_</a>  <a class="el" href="_a_e_s_e_c_b_8h.html#a63ffb2f4ad66f7981ed41de08d444a29">AESECB_Mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum for the direction of the ECB operation. </p>

</div>
</div>
<a id="a0aa5948ef2d83d659861aff16ddf95cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aa5948ef2d83d659861aff16ddf95cb">&sect;&nbsp;</a></span>AESECB_Operation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_a_e_s_e_c_b___operation__.html">AESECB_Operation_</a>  <a class="el" href="_a_e_s_e_c_b_8h.html#a0aa5948ef2d83d659861aff16ddf95cb">AESECB_Operation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Struct containing the parameters required for encrypting/decrypting and a message. </p>

</div>
</div>
<a id="a6b3d4d7c2079015bd053e3a977e743d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3d4d7c2079015bd053e3a977e743d6">&sect;&nbsp;</a></span>AESECB_OperationType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_a_e_s_e_c_b_8h.html#a00e385048eba5991c317d9b771789be7">AESECB_OperationType_</a>  <a class="el" href="_a_e_s_e_c_b_8h.html#a6b3d4d7c2079015bd053e3a977e743d6">AESECB_OperationType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum for the operation types supported by the driver. </p>

</div>
</div>
<a id="a5b0240a11da9753290532045e222618a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b0240a11da9753290532045e222618a">&sect;&nbsp;</a></span>AESECB_Config</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_a_e_s_e_c_b___config__.html">AESECB_Config_</a>  <a class="el" href="_a_e_s_e_c_b_8h.html#a5b0240a11da9753290532045e222618a">AESECB_Config</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AESECB Global configuration. </p>
<p>The AESECB_Config structure contains a set of pointers used to characterize the AESECB driver implementation.</p>
<p>This structure needs to be defined before calling <a class="el" href="_a_e_s_e_c_b_8h.html#a4f4274c6aa928e8e10d3e516e73f77ea" title="This function initializes the ECB module. ">AESECB_init()</a> and it must not be changed thereafter.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_a_e_s_e_c_b_8h.html#a4f4274c6aa928e8e10d3e516e73f77ea" title="This function initializes the ECB module. ">AESECB_init()</a> </dd></dl>

</div>
</div>
<a id="a2017e1521b3eeb49c8917dbe1dabf953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2017e1521b3eeb49c8917dbe1dabf953">&sect;&nbsp;</a></span>AESECB_CallbackFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* AESECB_CallbackFxn) (<a class="el" href="_a_e_s_e_c_b_8h.html#aca185011358823a4bbcd0c8f950bc960">AESECB_Handle</a> handle, int_fast16_t returnValue, <a class="el" href="_a_e_s_e_c_b_8h.html#a0aa5948ef2d83d659861aff16ddf95cb">AESECB_Operation</a> *operation, <a class="el" href="_a_e_s_e_c_b_8h.html#a6b3d4d7c2079015bd053e3a977e743d6">AESECB_OperationType</a> operationType)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The definition of a callback function used by the AESECB driver when used in <a class="el" href="_a_e_s_e_c_b_8h.html#a4f72d10dea0dcaa6d8cee8de8eb0981aa945f7703e248cd2d0fc2a08077030e62">AESECB_RETURN_BEHAVIOR_CALLBACK</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle of the client that started the ECB operation.</td></tr>
    <tr><td class="paramname">returnValue</td><td>The result of the CCM operation. May contain an error code. Informs the application of why the callback function was called.</td></tr>
    <tr><td class="paramname">operation</td><td>A pointer to an operation struct.</td></tr>
    <tr><td class="paramname">operationType</td><td>This parameter determines which operation the callback refers to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a257708194f9c44237ba4195fe5153ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a257708194f9c44237ba4195fe5153ac1">&sect;&nbsp;</a></span>AESECB_Params</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_a_e_s_e_c_b___params__.html">AESECB_Params_</a>  <a class="el" href="_a_e_s_e_c_b_8h.html#a257708194f9c44237ba4195fe5153ac1">AESECB_Params</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ECB Parameters. </p>
<p>ECB Parameters are used to with the <a class="el" href="_a_e_s_e_c_b_8h.html#aa09623a2b4bc9cfa608865bc502ca10e" title="This function opens a given ECB peripheral. ">AESECB_open()</a> call. Default values for these parameters are set using <a class="el" href="_a_e_s_e_c_b_8h.html#ab200c39cb5a9cc537a9a6047c89d5651" title="Function to initialize the AESECB_Params struct to its defaults. ">AESECB_Params_init()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_a_e_s_e_c_b_8h.html#ab200c39cb5a9cc537a9a6047c89d5651" title="Function to initialize the AESECB_Params struct to its defaults. ">AESECB_Params_init()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a4f72d10dea0dcaa6d8cee8de8eb0981a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f72d10dea0dcaa6d8cee8de8eb0981a">&sect;&nbsp;</a></span>AESECB_ReturnBehavior_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_a_e_s_e_c_b_8h.html#a4f72d10dea0dcaa6d8cee8de8eb0981a">AESECB_ReturnBehavior_</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The way in which ECB function calls return after performing an encryption + authentication or decryption + verification operation. </p>
<p>Not all ECB operations exhibit the specified return behavor. Functions that do not require significant computation and cannot offload that computation to a background thread behave like regular functions. Which functions exhibit the specfied return behavior is not implementation dependent. Specifically, a software-backed implementation run on the same CPU as the application will emulate the return behavior while not actually offloading the computation to the background thread.</p>
<p>AESECB functions exhibiting the specified return behavior have restrictions on the context from which they may be called.</p>
<table class="doxtable">
<tr>
<th></th><th>Task </th><th>Hwi </th><th>Swi  </th></tr>
<tr>
<td>AESECB_RETURN_BEHAVIOR_CALLBACK </td><td>X </td><td>X </td><td>X </td></tr>
<tr>
<td>AESECB_RETURN_BEHAVIOR_BLOCKING </td><td>X </td><td></td><td></td></tr>
<tr>
<td>AESECB_RETURN_BEHAVIOR_POLLING </td><td>X </td><td>X </td><td>X </td></tr>
</table>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4f72d10dea0dcaa6d8cee8de8eb0981aa945f7703e248cd2d0fc2a08077030e62"></a>AESECB_RETURN_BEHAVIOR_CALLBACK&#160;</td><td class="fielddoc"><p>The function call will return immediately while the ECB operation goes on in the background. The registered callback function is called after the operation completes. The context the callback function is called (task, HWI, SWI) is implementation-dependent. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4f72d10dea0dcaa6d8cee8de8eb0981aa09c85edf8278d95609ef9cda74e21640"></a>AESECB_RETURN_BEHAVIOR_BLOCKING&#160;</td><td class="fielddoc"><p>The function call will block while ECB operation goes on in the background. ECB operation results are available after the function returns. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4f72d10dea0dcaa6d8cee8de8eb0981aa8fb6022bf8730ca0f113fe339b3cf0d3"></a>AESECB_RETURN_BEHAVIOR_POLLING&#160;</td><td class="fielddoc"><p>The function call will continuously poll a flag while ECB operation goes on in the background. ECB operation results are available after the function returns. </p>
</td></tr>
</table>

</div>
</div>
<a id="aa3b7be874253e102ae98dd23c9319e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b7be874253e102ae98dd23c9319e9f">&sect;&nbsp;</a></span>AESECB_Mode_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_a_e_s_e_c_b_8h.html#aa3b7be874253e102ae98dd23c9319e9f">AESECB_Mode_</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum for the direction of the ECB operation. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa3b7be874253e102ae98dd23c9319e9fa444b0bc4a6fa39374155fc2f67fc6a94"></a>AESECB_MODE_ENCRYPT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa3b7be874253e102ae98dd23c9319e9fa2957e9be6c5c1ce87d927609ce47fb6d"></a>AESECB_MODE_DECRYPT&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a00e385048eba5991c317d9b771789be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00e385048eba5991c317d9b771789be7">&sect;&nbsp;</a></span>AESECB_OperationType_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_a_e_s_e_c_b_8h.html#a00e385048eba5991c317d9b771789be7">AESECB_OperationType_</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum for the operation types supported by the driver. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a00e385048eba5991c317d9b771789be7af9c903637981109af6af15c94aaf36b5"></a>AESECB_OPERATION_TYPE_ENCRYPT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a00e385048eba5991c317d9b771789be7af42ad89357fc2f25e83fb4d7033bc08a"></a>AESECB_OPERATION_TYPE_DECRYPT&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4f4274c6aa928e8e10d3e516e73f77ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f4274c6aa928e8e10d3e516e73f77ea">&sect;&nbsp;</a></span>AESECB_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AESECB_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the ECB module. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The AESECB_config structure must exist and be persistent before this function can be called. This function must also be called before any other ECB driver APIs. This function call does not modify any peripheral registers. </dd></dl>

</div>
</div>
<a id="ab200c39cb5a9cc537a9a6047c89d5651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab200c39cb5a9cc537a9a6047c89d5651">&sect;&nbsp;</a></span>AESECB_Params_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AESECB_Params_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_a_e_s_e_c_b_8h.html#a257708194f9c44237ba4195fe5153ac1">AESECB_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize the AESECB_Params struct to its defaults. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>An pointer to AESECB_Params structure for initialization</td></tr>
  </table>
  </dd>
</dl>
<p>Defaults values are: returnBehavior = AESECB_RETURN_BEHAVIOR_BLOCKING callbackFxn = NULL timeout = SemaphoreP_WAIT_FOREVER custom = NULL </p>

</div>
</div>
<a id="aa09623a2b4bc9cfa608865bc502ca10e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09623a2b4bc9cfa608865bc502ca10e">&sect;&nbsp;</a></span>AESECB_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_a_e_s_e_c_b_8h.html#aca185011358823a4bbcd0c8f950bc960">AESECB_Handle</a> AESECB_open </td>
          <td>(</td>
          <td class="paramtype">uint_least8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_a_e_s_e_c_b_8h.html#a257708194f9c44237ba4195fe5153ac1">AESECB_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function opens a given ECB peripheral. </p>
<dl class="section pre"><dt>Precondition</dt><dd>ECB controller has been initialized using <a class="el" href="_a_e_s_e_c_b_8h.html#a4f4274c6aa928e8e10d3e516e73f77ea" title="This function initializes the ECB module. ">AESECB_init()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Logical peripheral number for the ECB indexed into the AESECB_config table</td></tr>
    <tr><td class="paramname">params</td><td>Pointer to an parameter block, if NULL it will use default values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An AESECB_Handle on success or a NULL on an error or if it has been opened already.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_a_e_s_e_c_b_8h.html#a4f4274c6aa928e8e10d3e516e73f77ea" title="This function initializes the ECB module. ">AESECB_init()</a> </dd>
<dd>
<a class="el" href="_a_e_s_e_c_b_8h.html#a55c096b42583d88be9f044dcffad64a8" title="Function to close an ECB peripheral specified by the ECB handle. ">AESECB_close()</a> </dd></dl>

</div>
</div>
<a id="a55c096b42583d88be9f044dcffad64a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55c096b42583d88be9f044dcffad64a8">&sect;&nbsp;</a></span>AESECB_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AESECB_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_a_e_s_e_c_b_8h.html#aca185011358823a4bbcd0c8f950bc960">AESECB_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to close an ECB peripheral specified by the ECB handle. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_a_e_s_e_c_b_8h.html#aa09623a2b4bc9cfa608865bc502ca10e" title="This function opens a given ECB peripheral. ">AESECB_open()</a> has to be called first.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>An ECB handle returned from <a class="el" href="_a_e_s_e_c_b_8h.html#aa09623a2b4bc9cfa608865bc502ca10e" title="This function opens a given ECB peripheral. ">AESECB_open()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_a_e_s_e_c_b_8h.html#aa09623a2b4bc9cfa608865bc502ca10e" title="This function opens a given ECB peripheral. ">AESECB_open()</a> </dd></dl>

</div>
</div>
<a id="ac59e0fb45736632843a8e43cd2e79575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac59e0fb45736632843a8e43cd2e79575">&sect;&nbsp;</a></span>AESECB_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t AESECB_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_a_e_s_e_c_b_8h.html#aca185011358823a4bbcd0c8f950bc960">AESECB_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function performs implementation specific features on a given AESECB_Handle. </p>
<p>Commands for AESECB_control can originate from <a class="el" href="_a_e_s_e_c_b_8h.html" title="AESECB driver header. ">AESECB.h</a> or from implementation specific AESECB*.h (<em><a class="el" href="_a_e_s_e_c_b_c_c26_x_x_8h.html" title="AESECB driver implementation for the CC26XX family. ">AESECBCC26XX.h</a></em>, <em>AESECBMSP432.h</em>, etc.. ) files. While commands from <a class="el" href="_a_e_s_e_c_b_8h.html" title="AESECB driver header. ">AESECB.h</a> are API portable across driver implementations, not all implementations may support all these commands. Conversely, commands from driver implementation specific AESECB*.h files add unique driver capabilities but are not API portable across all AESECB driver implementations.</p>
<p>Commands supported by <a class="el" href="_a_e_s_e_c_b_8h.html" title="AESECB driver header. ">AESECB.h</a> follow an AESECB_CMD_&lt;cmd&gt; naming convention.<br />
 Commands supported by AESECB*.h follow an AESECB*_CMD_&lt;cmd&gt; naming convention.<br />
 Each control command defines <b>arg</b> differently. The types of <b>arg</b> are documented with each command.</p>
<p>See <a class="el" href="group___a_e_s_e_c_b___c_m_d.html">AESECB_control command codes</a> for command codes.</p>
<p>See <a class="el" href="group___a_e_s_e_c_b___s_t_a_t_u_s.html">AESECB_control return status codes</a> for status codes.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_a_e_s_e_c_b_8h.html#aa09623a2b4bc9cfa608865bc502ca10e" title="This function opens a given ECB peripheral. ">AESECB_open()</a> has to be called first.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>An AESECB handle returned from <a class="el" href="_a_e_s_e_c_b_8h.html#aa09623a2b4bc9cfa608865bc502ca10e" title="This function opens a given ECB peripheral. ">AESECB_open()</a></td></tr>
    <tr><td class="paramname">cmd</td><td><a class="el" href="_a_e_s_e_c_b_8h.html" title="AESECB driver header. ">AESECB.h</a> or AESECB*.h commands.</td></tr>
    <tr><td class="paramname">args</td><td>An optional R/W (read/write) command argument accompanied with cmd</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Implementation specific return codes. Negative values indicate unsuccessful operations.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_a_e_s_e_c_b_8h.html#aa09623a2b4bc9cfa608865bc502ca10e" title="This function opens a given ECB peripheral. ">AESECB_open()</a> </dd></dl>

</div>
</div>
<a id="a44a248dfcc9794b28a2eb8eb5570af2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44a248dfcc9794b28a2eb8eb5570af2d">&sect;&nbsp;</a></span>AESECB_Operation_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AESECB_Operation_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_a_e_s_e_c_b_8h.html#a0aa5948ef2d83d659861aff16ddf95cb">AESECB_Operation</a> *&#160;</td>
          <td class="paramname"><em>operationStruct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to initialize an AESECB_Operation struct to its defaults. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operationStruct</td><td>An pointer to AESECB_Operation structure for initialization</td></tr>
  </table>
  </dd>
</dl>
<p>Defaults values are all zeros. </p>

</div>
</div>
<a id="a8b760e2e52d714c3fb8faf74feb38b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b760e2e52d714c3fb8faf74feb38b3a">&sect;&nbsp;</a></span>AESECB_oneStepEncrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t AESECB_oneStepEncrypt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_a_e_s_e_c_b_8h.html#aca185011358823a4bbcd0c8f950bc960">AESECB_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_a_e_s_e_c_b_8h.html#a0aa5948ef2d83d659861aff16ddf95cb">AESECB_Operation</a> *&#160;</td>
          <td class="paramname"><em>operation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to perform an AESECB encryption operation in one call. </p>
<dl class="section note"><dt>Note</dt><dd>None of the buffers provided as arguments may be altered by the application during an ongoing operation. Doing so can yield corrupted ciphertext or incorrect authentication.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_a_e_s_e_c_b_8h.html#aa09623a2b4bc9cfa608865bc502ca10e" title="This function opens a given ECB peripheral. ">AESECB_open()</a> and <a class="el" href="_a_e_s_e_c_b_8h.html#a44a248dfcc9794b28a2eb8eb5570af2d" title="Function to initialize an AESECB_Operation struct to its defaults. ">AESECB_Operation_init()</a> have to be called first.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>An ECB handle returned from <a class="el" href="_a_e_s_e_c_b_8h.html#aa09623a2b4bc9cfa608865bc502ca10e" title="This function opens a given ECB peripheral. ">AESECB_open()</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">operation</td><td>A pointer to a struct containing the parameters required to perform the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_a_e_s_e_c_b_8h.html#abdd64e5e2b446ef0b884f9d3862d0463" title="Function to perform an AESECB decryption in one call. ">AESECB_oneStepDecrypt()</a> </dd></dl>

</div>
</div>
<a id="abdd64e5e2b446ef0b884f9d3862d0463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd64e5e2b446ef0b884f9d3862d0463">&sect;&nbsp;</a></span>AESECB_oneStepDecrypt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t AESECB_oneStepDecrypt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_a_e_s_e_c_b_8h.html#aca185011358823a4bbcd0c8f950bc960">AESECB_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_a_e_s_e_c_b_8h.html#a0aa5948ef2d83d659861aff16ddf95cb">AESECB_Operation</a> *&#160;</td>
          <td class="paramname"><em>operation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to perform an AESECB decryption in one call. </p>
<dl class="section note"><dt>Note</dt><dd>None of the buffers provided as arguments may be altered by the application during an ongoing operation. Doing so can yield corrupted plaintext or incorrectly failed verification.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_a_e_s_e_c_b_8h.html#aa09623a2b4bc9cfa608865bc502ca10e" title="This function opens a given ECB peripheral. ">AESECB_open()</a> and <a class="el" href="_a_e_s_e_c_b_8h.html#a44a248dfcc9794b28a2eb8eb5570af2d" title="Function to initialize an AESECB_Operation struct to its defaults. ">AESECB_Operation_init()</a> have to be called first.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>An ECB handle returned from <a class="el" href="_a_e_s_e_c_b_8h.html#aa09623a2b4bc9cfa608865bc502ca10e" title="This function opens a given ECB peripheral. ">AESECB_open()</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">operation</td><td>A pointer to a struct containing the parameters required to perform the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_a_e_s_e_c_b_8h.html#a8b760e2e52d714c3fb8faf74feb38b3a" title="Function to perform an AESECB encryption operation in one call. ">AESECB_oneStepEncrypt()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a7a7eab07a0ed40f1e9320f973a74fb8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a7eab07a0ed40f1e9320f973a74fb8e">&sect;&nbsp;</a></span>AESECB_defaultParams</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_a_e_s_e_c_b_8h.html#a257708194f9c44237ba4195fe5153ac1">AESECB_Params</a> AESECB_defaultParams</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default AESECB_Params structure. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_a_e_s_e_c_b_8h.html#ab200c39cb5a9cc537a9a6047c89d5651" title="Function to initialize the AESECB_Params struct to its defaults. ">AESECB_Params_init()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
Copyright  2018, Texas Instruments Incorporated
</small>
</body>
</html>
