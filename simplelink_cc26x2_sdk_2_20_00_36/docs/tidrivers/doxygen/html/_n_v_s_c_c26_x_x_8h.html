<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>NVSCC26XX.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_2298ed0e5bfee6f293aea6c715ac7f7c.html">exports</a></li><li class="navelem"><a class="el" href="dir_909bee6dba95683a10cf8e43b6520a31.html">tidrivers_cc13xx_cc26xx_3_60_01_00</a></li><li class="navelem"><a class="el" href="dir_c5f8bfd2b00c3d9482b35ab5c4e473f6.html">source</a></li><li class="navelem"><a class="el" href="dir_06d62f3489950a654127c0b824c52048.html">ti</a></li><li class="navelem"><a class="el" href="dir_f72c65173629b6c97d424cefc852539a.html">drivers</a></li><li class="navelem"><a class="el" href="dir_b251034db9b193b0da9cae51c75fe834.html">nvs</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">NVSCC26XX.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Non-Volatile Storage driver for CC13XX/CC26XX devices. </p>
<hr/>
<h2>Interrupt Latency During Flash Operations</h2>
<p>When writing or erasing flash, interrupts must be disabled to avoid executing code in flash while the flash is being reprogrammed. This constraint is handled by the driver. Application code does not need to safeguard against this.</p>
<p>Additionally, to avoid extremely large interrupt latencies that would be incurred if entire blocks were written with interrupts disabled, block writes to flash are broken into multiple smaller sizes.</p>
<p>Even with this scheme in place, latencies of roughly 64 microseconds will be incurred while flash is being written to.</p>
<p>A similar caveat applies to flash erase operations. Erasing an entire flash sector (the minimal amount that can be erased at a time) can take roughly 8 milliseconds. This entire operation must be performed with interrupts disabled. Here again, this requirement is met internally by the driver and flash region erases are performed one sector at a time to minimize this significant latency impact.</p>
<p>Care must be taken by the user to not perform flash write or erase operations during latency critical phases of an application. See the <a class="el" href="_n_v_s_8h.html#a62d1593df9acb6d3c6446f1719f3bf28" title="Function to lock the NVS driver. ">NVS_lock()</a> and <a class="el" href="_n_v_s_8h.html#a01fb843c26ca406c5c9463eae6b0b817" title="Function to unlock the NVS driver. ">NVS_unlock()</a> API descriptions for more information.</p>
<h2>Maximum flash writes before erase</h2>
<p>On CC13XX &amp; CC26XX memory rows can be 128 or 256 bytes in length; refer to the device datasheet for the exact size. A maximum of 83 write operations can be performed on a memory row. Once the limit is reached, the row must be erased before it is written to again.</p>
<dl class="section note"><dt>Note</dt><dd>The 83 write limit persists through device reset &amp; power cycles. If 60 write operations were performed on a memory page &amp; the device is reset; the page can still only be written to 23 more times before it must be erased.</dd></dl>
<p>A write "Scoreboard" can be enabled in this driver; the scoreboard keeps track of how many times a page has been written to. It is provided as a debug tool to ensure the 83 write limit is not exceeded. If a page is written to more than 83 times, the NVSCC26XX driver will spin forever. Each byte in the scoreboard corresponds to a memory page in the NVS region. The byte is incremented when the memory is written to &amp; set to 0 when erased.</p>
<p>To enable the "scoreboard" the "NVSCC26XX_INSTRUMENTED" symbol must be defined when the driver is compiled. Three new fields are added to the <a class="el" href="struct_n_v_s_c_c26_x_x___h_w_attrs.html" title="NVSCC26XX hardware attributes. ">NVSCC26XX_HWAttrs</a> structure:</p><ul>
<li>scoreboard - a buffer provided by the application where each byte represents how many times a page has been written to.</li>
<li>scoreboardSize - number of bytes in the scoreboard. *flashPageSize - number of bytes in a flash page (i.e. 128 or 256)</li>
</ul>
<p>When configured correctly, the scoreboard can be viewed in a memory browser.</p>
<dl class="section note"><dt>Note</dt><dd>The scoreboard will only keep track of writes to flash within a NVS region using a NVS driver. Writes performed outside the NVS region or without the NVS driver are untracked.</dd>
<dd>
The scoreboard is in RAM &amp; will be lost on reset or power cycle.</dd></dl>
<hr/>
</div><div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
</div>
<p><a href="_n_v_s_c_c26_x_x_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_n_v_s_c_c26_x_x___h_w_attrs.html">NVSCC26XX_HWAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NVSCC26XX hardware attributes.  <a href="struct_n_v_s_c_c26_x_x___h_w_attrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_n_v_s_c_c26_x_x___object.html">NVSCC26XX_Object</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aa21de44fea696d5e49503a7e0d9a00b7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_n_v_s_c_c26_x_x_8h.html#aa21de44fea696d5e49503a7e0d9a00b7">NVSCC26XX_STATUS_LOW_VOLTAGE</a>&#160;&#160;&#160;(<a class="el" href="group___n_v_s___c_o_n_t_r_o_l.html#gad82fd139152ca14946c80c6c91edb4a0">NVS_STATUS_RESERVED</a> - 1)</td></tr>
<tr class="memdesc:aa21de44fea696d5e49503a7e0d9a00b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error status code returned by <a class="el" href="_n_v_s_8h.html#a4f309d160ac4641c89501adc95d170b3" title="Erase size bytes of the region beginning at offset bytes from the base of the region referenced by th...">NVS_erase()</a>, <a class="el" href="_n_v_s_8h.html#aae7abe0cb889a6d0cc1858bfc69ab7e0" title="Write data to the NVS region associated with the NVS_Handle. ">NVS_write()</a>.  <a href="#aa21de44fea696d5e49503a7e0d9a00b7">More...</a><br /></td></tr>
<tr class="separator:aa21de44fea696d5e49503a7e0d9a00b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a38491f6eb4860eab3549daf9ad4c273a"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_n_v_s_c_c26_x_x___h_w_attrs.html">NVSCC26XX_HWAttrs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_n_v_s_c_c26_x_x_8h.html#a38491f6eb4860eab3549daf9ad4c273a">NVSCC26XX_HWAttrs</a></td></tr>
<tr class="memdesc:a38491f6eb4860eab3549daf9ad4c273a"><td class="mdescLeft">&#160;</td><td class="mdescRight">NVSCC26XX hardware attributes.  <a href="#a38491f6eb4860eab3549daf9ad4c273a">More...</a><br /></td></tr>
<tr class="separator:a38491f6eb4860eab3549daf9ad4c273a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008a277378544c3ce2b65a2e9688d49e"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_n_v_s_c_c26_x_x___object.html">NVSCC26XX_Object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_n_v_s_c_c26_x_x_8h.html#a008a277378544c3ce2b65a2e9688d49e">NVSCC26XX_Object</a></td></tr>
<tr class="separator:a008a277378544c3ce2b65a2e9688d49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ade3114c185df6a15ec62305dd5c6f6cc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_n_v_s___fxn_table.html">NVS_FxnTable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_n_v_s_c_c26_x_x_8h.html#ade3114c185df6a15ec62305dd5c6f6cc">NVSCC26XX_fxnTable</a></td></tr>
<tr class="separator:ade3114c185df6a15ec62305dd5c6f6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="aa21de44fea696d5e49503a7e0d9a00b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa21de44fea696d5e49503a7e0d9a00b7">&sect;&nbsp;</a></span>NVSCC26XX_STATUS_LOW_VOLTAGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NVSCC26XX_STATUS_LOW_VOLTAGE&#160;&#160;&#160;(<a class="el" href="group___n_v_s___c_o_n_t_r_o_l.html#gad82fd139152ca14946c80c6c91edb4a0">NVS_STATUS_RESERVED</a> - 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error status code returned by <a class="el" href="_n_v_s_8h.html#a4f309d160ac4641c89501adc95d170b3" title="Erase size bytes of the region beginning at offset bytes from the base of the region referenced by th...">NVS_erase()</a>, <a class="el" href="_n_v_s_8h.html#aae7abe0cb889a6d0cc1858bfc69ab7e0" title="Write data to the NVS region associated with the NVS_Handle. ">NVS_write()</a>. </p>
<p>This error status is returned if the system voltage is too low to safely perform the flash operation. Voltage must be 1.5V or greater. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a38491f6eb4860eab3549daf9ad4c273a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38491f6eb4860eab3549daf9ad4c273a">&sect;&nbsp;</a></span>NVSCC26XX_HWAttrs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_n_v_s_c_c26_x_x___h_w_attrs.html">NVSCC26XX_HWAttrs</a>  <a class="el" href="struct_n_v_s_c_c26_x_x___h_w_attrs.html">NVSCC26XX_HWAttrs</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NVSCC26XX hardware attributes. </p>
<p>The NVSCC26XX hardware attributes define hardware specific settings for a NVS driver instance.</p>
<dl class="section note"><dt>Note</dt><dd>Care must be taken to ensure that the linker does not place application content (such as .text or .const) in the flash regions defined by the this hardware attributes structure.</dd></dl>
<p>For CCS and IAR tools, defining and reserving flash memory regions can be done entirely within the Board.c file. For GCC, additional content is required in the application's linker script to achieve the same result.</p>
<p>The example below defines a char array <code>flashBuf</code>. Preprocessor logic is used so that this example will work with either the TI, IAR or GCC tools. For the TI and IAR tools, pragmas are used to place <code>flashBuf</code> at the flash location specified by <a class="el" href="struct_n_v_s_c_c26_x_x___h_w_attrs.html#ad5ee322e543d49b4c177f28f4e96f884">NVSCC26XX_HWAttrs.regionBase</a>.</p>
<p>For the GCC tool, the <code>flashBuf</code> array is placed into a named linker output section, <code></code>.nvs. This section is defined in the application's linker script. The section placement command is carefully chosen to only RESERVE space for the <code>flashBuf</code> array, and not to actually initialize it during the application load process, thus preserving the content of flash.</p>
<p>Regardless of tool chain, the <code>flashBuf</code> array in the example below is placed at the <code>NVS_REGIONS_BASE</code> address and has an overall size of <code>REGIONSIZE</code> bytes. Theoretically, the memory reserved by <code>flashBuf</code> can be divided into four separate regions, each having a size of <code>SECTORSIZE</code> bytes. Each region must always be aligned to the flash sector size, <code>SECTORSIZE</code>. This example below shows two regions defined.</p>
<p>An array of two <a class="el" href="struct_n_v_s_c_c26_x_x___h_w_attrs.html" title="NVSCC26XX hardware attributes. ">NVSCC26XX_HWAttrs</a> structures is defined. Each index of this structure defines a region of on-chip flash memory. Both regions utilize memory reserved by the <code>flashBuf</code> array. The two regions do not overlap or share the same physical memory locations. The two regions do however exist adjacent to each other in physical memory. The first region is defined as starting at the <code>NVS_REGIONS_BASE</code> address and has a size equal to the flash sector size, as defined by <code>SECTORSIZE</code>. The second region is defined as starting at (NVS_REGIONS_BASE + SECTORSIZE), that is, the <code>NVS_REGIONS_BASE</code> address offset by <code>SECTORSIZE</code> bytes. The second region has a size equal to (3 * SECTORSIZE) bytes. These regions together fully occupy <code>REGIONSIZE</code> bytes of physical on-chip flash memory as reserved by the <code>flashBuf</code> array.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define NVS_REGIONS_BASE 0x1B000</span></div><div class="line"><span class="preprocessor">#define SECTORSIZE       0x1000</span></div><div class="line"><span class="preprocessor">#define REGIONSIZE       (SECTORSIZE * 4)</span></div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Reserve flash sectors for NVS driver use</span></div><div class="line"><span class="comment">// by placing an uninitialized byte array</span></div><div class="line"><span class="comment">// at the desired flash address.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="preprocessor">#if defined(__TI_COMPILER_VERSION__)</span></div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  Place uninitialized array at FLASH_REGION_BASE</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="preprocessor">#pragma LOCATION(flashBuf, FLASH_REGION_BASE);</span></div><div class="line"><span class="preprocessor">#pragma NOINIT(flashBuf);</span></div><div class="line"><span class="keywordtype">char</span> flashBuf[REGIONSIZE];</div><div class="line"></div><div class="line"><span class="preprocessor">#elif defined(__IAR_SYSTEMS_ICC__)</span></div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  Place uninitialized array at FLASH_REGION_BASE</span></div><div class="line"><span class="comment">//</span></div><div class="line">__no_init <span class="keywordtype">char</span> flashBuf[REGIONSIZE] @ FLASH_REGION_BASE;</div><div class="line"></div><div class="line"><span class="preprocessor">#elif defined(__GNUC__)</span></div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  Place the flash buffers in the .nvs section created in the gcc linker file.</span></div><div class="line"><span class="comment">//  The .nvs section enforces alignment on a sector boundary but may</span></div><div class="line"><span class="comment">//  be placed anywhere in flash memory.  If desired the .nvs section can be set</span></div><div class="line"><span class="comment">//  to a fixed address by changing the following in the gcc linker file:</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  .nvs (FIXED_FLASH_ADDR) (NOLOAD) : AT (FIXED_FLASH_ADDR) {</span></div><div class="line"><span class="comment">//       *(.nvs)</span></div><div class="line"><span class="comment">//  } &gt; REGION_TEXT</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line">__attribute__ ((section (<span class="stringliteral">&quot;.nvs&quot;</span>)))</div><div class="line">char flashBuf[REGIONSIZE];</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><a class="code" href="struct_n_v_s_c_c26_x_x___h_w_attrs.html">NVSCC26XX_HWAttrs</a> nvsCC26XXHWAttrs[2] = {</div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// region 0 is 1 flash sector in length.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    {</div><div class="line">        .<a class="code" href="struct_n_v_s_c_c26_x_x___h_w_attrs.html#ad5ee322e543d49b4c177f28f4e96f884">regionBase</a> = (<span class="keywordtype">void</span> *)flashBuf,</div><div class="line">        .regionSize = SECTORSIZE,</div><div class="line">    },</div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// region 1 is 3 flash sectors in length.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    {</div><div class="line">        .regionBase = (<span class="keywordtype">void</span> *)(flashBuf + SECTORSIZE),</div><div class="line">        .regionSize = SECTORSIZE * 3,</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>Example GCC linker script file content. This example places an output section, <code></code>.nvs, at the memory address <code>0x1B000</code>. The <code>NOLOAD</code> directive is used so that this memory is not initialized during program load to the target.</p>
<div class="fragment"><div class="line">MEMORY</div><div class="line">{</div><div class="line">    FLASH (RX)      : ORIGIN = 0x00000000, LENGTH = 0x0001ffa8</div><div class="line">    FLASH_CCFG (RX) : ORIGIN = 0x0001ffa8, LENGTH = 0x00000058</div><div class="line">    SRAM (RWX)      : ORIGIN = 0x20000000, LENGTH = 0x00005000</div><div class="line">}</div><div class="line"></div><div class="line">.nvs (0x1b000) (NOLOAD) : AT (0x1b000) {</div><div class="line">    *(.nvs)</div><div class="line">} &gt; REGION_TEXT</div></div><!-- fragment --><p>If the write "scoreboard" is enabled, three new fields are added to the <a class="el" href="struct_n_v_s_c_c26_x_x___h_w_attrs.html" title="NVSCC26XX hardware attributes. ">NVSCC26XX_HWAttrs</a> structure:</p><ul>
<li>scoreboard - a buffer provided by the application where each byte represents how many times a page has been written to. It is important that this buffer be large enough such that there is a byte for each page of memory in the NVS region. For example:<ul>
<li>64k NVS region</li>
<li>256 byte page size</li>
<li>64k / 256 = 256; the scoreboard buffer must be 256 bytes in length</li>
</ul>
</li>
<li>scoreboardSize - number of bytes in the scoreboard.</li>
<li>flashPageSize - number of bytes in a flash page (i.e. 128 or 256) </li>
</ul>

</div>
</div>
<a id="a008a277378544c3ce2b65a2e9688d49e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008a277378544c3ce2b65a2e9688d49e">&sect;&nbsp;</a></span>NVSCC26XX_Object</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_n_v_s_c_c26_x_x___object.html">NVSCC26XX_Object</a>  <a class="el" href="struct_n_v_s_c_c26_x_x___object.html">NVSCC26XX_Object</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ade3114c185df6a15ec62305dd5c6f6cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade3114c185df6a15ec62305dd5c6f6cc">&sect;&nbsp;</a></span>NVSCC26XX_fxnTable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_n_v_s___fxn_table.html">NVS_FxnTable</a> NVSCC26XX_fxnTable</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
Copyright  2018, Texas Instruments Incorporated
</small>
</body>
</html>
